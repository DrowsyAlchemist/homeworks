using System;
using System.Collections.Generic;

namespace Lessons
{
    class Lessons
    {
        public static void Main()
        {
            Game game = new Game();
            game.ConductBalanceTest();
        }
    }

    class Logger
    {
        private bool _testMode = false;
        public ConsoleColor Color { get; set; }

        public Logger(ConsoleColor color)
        {
            Color = color;
        }

        public Logger(bool isTestMode)
        {
            Color = ConsoleColor.White;
            _testMode = isTestMode;
        }

        public void PrintMessage(string message)
        {
            if (_testMode)
                return;

            ConsoleColor defaultColor = Console.ForegroundColor;
            Console.ForegroundColor = Color;
            Console.Write(message);
            Console.ForegroundColor = defaultColor;
        }
    }

    class Game
    {
        private const int ConsoleWidth = 120;
        private const int ConsoleHeight = 50;
        private Gladiator[] _gladiators =
               {new Swordsman(),
                new Spearman(),
                new Berserk(),
                new Wizard(),
                new Assassin()};
        private Gladiator _firstGladiator;
        private Gladiator _secondGladiator;

        public void StartNewGame()
        {
            Console.SetWindowSize(ConsoleWidth, ConsoleHeight);
            ChooseOpponents();
            Battle battle = new Battle(_firstGladiator, _secondGladiator);
            battle.Conduct();
        }

        public void ConductBalanceTest()
        {
            Console.SetWindowSize(ConsoleWidth, ConsoleHeight);
            ChooseOpponents();
            Console.WriteLine("Укажите количество боёв. Рекомендуется 5000000.");
            int.TryParse(Console.ReadLine(), out int battlesCounter);
            Console.WriteLine("Выполняется тест. Это может занять несколько минут.");
            int fisrstWarriorWinsCounter = 0;

            for (int i = 0; i < battlesCounter; i++)
            {
                Battle battle = new Battle(_firstGladiator.Clone(), _secondGladiator.Clone(), isTestMode: true);
                fisrstWarriorWinsCounter += battle.TestConduct();
            }
            float fisrstWarriorWinsPercent = ((float)fisrstWarriorWinsCounter / (float)battlesCounter) * 100f;
            Console.WriteLine($"Первый боец побеждал в {fisrstWarriorWinsPercent}% битв.");
            Console.ReadKey(true);
        }

        private void ChooseOpponents()
        {
            Console.WriteLine("Выберите первого бойца:\n");
            ChooseGladiator(ref _firstGladiator);
            Console.WriteLine("Выберите второго бойца:\n");
            ChooseGladiator(ref _secondGladiator);

            if (_firstGladiator.Equals(_secondGladiator))
                _secondGladiator = _firstGladiator.Clone();
        }

        private void ChooseGladiator(ref Gladiator gladiator)
        {
            int gladiatorNumber = 0;

            while (gladiatorNumber <= 0 || gladiatorNumber > _gladiators.Length)
            {
                ShowAllGlagiators();
                gladiatorNumber = GetGladiatorNumber();
                Console.Clear();
            }
            gladiator = _gladiators[gladiatorNumber - 1];
        }

        private int GetGladiatorNumber()
        {
            bool isCorrectGladiatorNumber = false;
            int gladiatorNumber = 0;

            while (!isCorrectGladiatorNumber)
            {
                Console.Write(" Боец: ");
                isCorrectGladiatorNumber = int.TryParse(Console.ReadLine(), out gladiatorNumber);
                Console.WriteLine();
            }
            return gladiatorNumber;
        }

        private void ShowAllGlagiators()
        {
            for (int i = 0; i < _gladiators.Length; i++)
            {
                Console.Write($" {i + 1}. ");
                _gladiators[i].ShowInfo();
            }
        }
    }

    class Battle
    {
        private const int CursorStartTopPosition = 4;
        private const int CursorTopPositionThreshold = 25;
        private const ConsoleColor FirstGladiatorColor = ConsoleColor.Red;
        private const ConsoleColor SecondGladiatorColor = ConsoleColor.Cyan;
        private Gladiator _firstGladiator;
        private Gladiator _secondGladiator;
        private int _cursorTopPosition = CursorStartTopPosition;
        private Random _random = new Random();
        private Logger _logger = new Logger(ConsoleColor.Green);

        public Battle(Gladiator firstGladiator, Gladiator secondGladiator, bool isTestMode = false)
        {
            _firstGladiator = firstGladiator;
            _firstGladiator.Random = _random;
            _secondGladiator = secondGladiator;
            _secondGladiator.Random = _random;

            if (isTestMode)
            {
                _firstGladiator.Logger = new Logger(isTestMode: true);
                _secondGladiator.Logger = new Logger(isTestMode: true);
            }
            else
            {
                _firstGladiator.Logger = new Logger(FirstGladiatorColor);
                _secondGladiator.Logger = new Logger(SecondGladiatorColor);
            }
        }

        public void Conduct()
        {
            PrintGladiatorsHealthBars();
            Console.ReadKey(true);

            while (_firstGladiator.CurrentHealth > 0
                && _secondGladiator.CurrentHealth > 0)
            {
                if (_cursorTopPosition > CursorTopPositionThreshold)
                {
                    Console.Clear();
                    Console.CursorTop = CursorStartTopPosition;
                }
                _firstGladiator.HitTheOpponent(_secondGladiator);
                _secondGladiator.HitTheOpponent(_firstGladiator);
                _cursorTopPosition = Console.CursorTop + 1;
                PrintGladiatorsHealthBars();
                Console.ReadKey(true);
            }
            ShowBattleResults();
        }

        public int TestConduct()
        {
            while (_firstGladiator.CurrentHealth > 0
                && _secondGladiator.CurrentHealth > 0)
            {
                _firstGladiator.HitTheOpponent(_secondGladiator);
                _secondGladiator.HitTheOpponent(_firstGladiator);
            }
            return (_firstGladiator.CurrentHealth > 0) ? 1 : 0;
        }

        private void ShowBattleResults()
        {
            Gladiator winner = (_firstGladiator.CurrentHealth > 0) ? _firstGladiator : _secondGladiator;
            _logger.PrintMessage("\nБой окончен!\n\nПобедитель: ");
            winner.Logger.PrintMessage(winner.Name);
            Console.ReadKey(true);
        }

        private void PrintGladiatorsHealthBars()
        {
            Console.SetCursorPosition(0, 0);
            _firstGladiator.PrintHealthBar();
            _secondGladiator.PrintHealthBar();
            Console.CursorTop = _cursorTopPosition;
        }
    }

    abstract class Gladiator
    {
        protected const int MaxPercent = 100;
        protected const int MaxDamageInPercents = 140;
        protected const int MinDamageInPercents = 60;
        protected string Weapon;
        protected string WeaponInInstrumentalCase;
        protected string SpecialAbility;
        protected float MaxHealth = 250f;
        protected float ArmorInPercents = 30f;
        protected float Strength = 30f;
        protected float OutputDamage;

        public string Name { get; protected set; }
        public float CurrentHealth { get; protected set; }
        public Random Random { protected get; set; } = new Random();
        public Logger Logger { get; set; } = new Logger(ConsoleColor.White);

        public Gladiator Clone()
        {
            switch (this)
            {
                case Swordsman swordsman:
                    return new Swordsman();
                case Spearman spearman:
                    return new Spearman();
                case Berserk berserk:
                    return new Berserk();
                case Wizard wizard:
                    return new Wizard();
                case Assassin assassin:
                    return new Assassin();
                default:
                    throw new Exception();
            }
        }

        public virtual void HitTheOpponent(Gladiator opponent)
        {
            if (CurrentHealth <= 0)
            {
                Logger.PrintMessage($"{Name} больше не может сражаться.\n");
                return;
            }
            Logger.PrintMessage($"{Name} нанёс удар {WeaponInInstrumentalCase}. ");
            OutputDamage = GetRandomDamage();
            opponent.TakeAHit(OutputDamage);
        }

        public virtual float TakeAHit(float inputDamage)
        {
            if (ArmorInPercents > 100)
                throw new ArgumentException();

            float resultDamage = inputDamage * (1 - (ArmorInPercents / MaxPercent));
            CurrentHealth -= resultDamage;
            Logger.PrintMessage($"{Name} получил {resultDamage:0.0} урона.\n");
            return resultDamage;
        }

        public void ShowInfo()
        {
            Console.WriteLine(
                $" {Name}\n" +
                $" Оружие: {Weapon}\n" +
                $" Здоровье: {MaxHealth}\n" +
                $" Защита: {ArmorInPercents}\n" +
                $" Сила: {Strength}\n" +
                $" Способность: {SpecialAbility}\n");
        }

        public void PrintHealthBar()
        {
            int scalingFactor = 40;
            Logger.PrintMessage("|" + Name + "| ");
            int relativeHealth;

            if (CurrentHealth <= 0)
                relativeHealth = 0;
            else
                relativeHealth = (int)(scalingFactor * (CurrentHealth / MaxHealth));

            if ((CurrentHealth > 0) && (relativeHealth < scalingFactor))
                relativeHealth++;

            ConsoleColor defaultBackgroundColor = Console.BackgroundColor;
            Console.Write("[");
            Console.BackgroundColor = Logger.Color;

            for (int i = 0; i < relativeHealth; i++)
                Logger.PrintMessage("_");

            Console.BackgroundColor = ConsoleColor.White;

            for (int i = relativeHealth; i < scalingFactor; i++)
                Console.Write("_");

            Console.BackgroundColor = defaultBackgroundColor;
            Console.WriteLine("]\n");
        }

        protected float GetRandomDamage()
        {
            float damageScaleFactor = (float)Random.Next(MinDamageInPercents, MaxDamageInPercents) / MaxPercent;
            return Strength * damageScaleFactor;
        }
    }

    class Swordsman : Gladiator
    {
        private const float secondHitProbability = 20;

        public Swordsman()
        {
            Name = "Мечник";
            Weapon = "Одноручный меч";
            WeaponInInstrumentalCase = "мечом";
            CurrentHealth = MaxHealth;
            SpecialAbility = $"{secondHitProbability}% вероятность нанести второй удар.";
        }

        public override void HitTheOpponent(Gladiator opponent)
        {
            base.HitTheOpponent(opponent);

            if (CurrentHealth > 0)
                HitSecondTime(opponent);
        }

        private void HitSecondTime(Gladiator opponent)
        {
            if ((Random.Next(0, MaxPercent) < secondHitProbability))
            {
                Logger.PrintMessage($"{Name} ударил второй раз. ");
                OutputDamage = GetRandomDamage();
                opponent.TakeAHit(OutputDamage);
            }
        }
    }

    class Wizard : Gladiator
    {
        private const float DamagePercentСonvertedToHealth = 80;
        private const int TurnsAbilityActivated = 3;
        private int _currentTurn = 1;

        public Wizard()
        {
            Name = "Колдун";
            Weapon = "Магия";
            MaxHealth *= 0.7f;
            CurrentHealth = MaxHealth;
            ArmorInPercents *= 0.4f;
            Strength *= 1.65f;
            SpecialAbility = $"Каждые {TurnsAbilityActivated} хода " +
                $"{DamagePercentСonvertedToHealth}% нанесённого врагу урона переходят в очки здоровья.";
        }

        public override void HitTheOpponent(Gladiator opponent)
        {
            if (CurrentHealth > 0 && (_currentTurn % TurnsAbilityActivated == 0))
            {
                Logger.PrintMessage($"{Name} нанёс удар {WeaponInInstrumentalCase}. ");
                OutputDamage = GetRandomDamage();
                float enemyReceivedDamage = opponent.TakeAHit(OutputDamage);
                ConvertDamageToHealth(enemyReceivedDamage);
            }
            else
            {
                base.HitTheOpponent(opponent);
            }
            _currentTurn++;
        }

        private void ConvertDamageToHealth(float opponentReceivedDamage)
        {
            float restoredHealth = opponentReceivedDamage * DamagePercentСonvertedToHealth / MaxPercent;
            CurrentHealth += restoredHealth;
            Logger.PrintMessage($"{Name} восстановил {restoredHealth: 0.0} здоровья.\n");
        }
    }

    class Berserk : Gladiator
    {
        private const float DamageIncreaseFactor = 2;
        private const float IncreaseDamageProbability = 15;

        public Berserk()
        {
            Name = "Берсерк";
            Weapon = "Двуручный топор";
            WeaponInInstrumentalCase = "топором";
            MaxHealth *= 1.1f;
            CurrentHealth = MaxHealth;
            ArmorInPercents *= 0f;
            Strength *= 1.4f;
            SpecialAbility = $"{IncreaseDamageProbability}% шанс нанести {DamageIncreaseFactor}-кратный урон.";
        }

        public override void HitTheOpponent(Gladiator opponent)
        {
            if (CurrentHealth > 0 && (Random.Next(0, MaxPercent) < IncreaseDamageProbability))
                DoIncreasedDamage(opponent);
            else
                base.HitTheOpponent(opponent);
        }

        private void DoIncreasedDamage(Gladiator opponent)
        {
            Logger.PrintMessage($"{Name} нанёс усиленный удар {WeaponInInstrumentalCase}. ");
            OutputDamage = DamageIncreaseFactor * GetRandomDamage();
            opponent.TakeAHit(OutputDamage);
        }
    }

    class Spearman : Gladiator
    {
        private const float DodgingProbability = 10;
        private const float DamageIncreaseFactor = 2;
        private const float IncreaseDamageProbability = 10;

        public Spearman()
        {
            Name = "Копейщик";
            Weapon = "Копьё";
            WeaponInInstrumentalCase = "копьём";
            CurrentHealth = MaxHealth;
            ArmorInPercents *= 0.6f;
            Strength *= 1.15f;
            SpecialAbility = $"{DodgingProbability}% вероятность увернуться от удара. " +
                $"{IncreaseDamageProbability}% шанс нанести {DamageIncreaseFactor}-кратный урон.";
        }

        public override void HitTheOpponent(Gladiator opponent)
        {
            if (CurrentHealth > 0 && (Random.Next(0, MaxPercent) < IncreaseDamageProbability))
                DoIncreasedDamage(opponent);
            else
                base.HitTheOpponent(opponent);
        }

        public override float TakeAHit(float damage)
        {
            if (Random.Next(0, MaxPercent) < DodgingProbability)
                return DodgeTheHit();
            else
                return base.TakeAHit(damage);
        }

        private void DoIncreasedDamage(Gladiator opponent)
        {
            Logger.PrintMessage($"{Name} нанёс усиленный удар {WeaponInInstrumentalCase}. ");
            OutputDamage = DamageIncreaseFactor * GetRandomDamage();
            opponent.TakeAHit(OutputDamage);
        }

        private float DodgeTheHit()
        {
            Logger.PrintMessage($"{Name} увернулся от удара.\n");
            return 0;
        }
    }

    class Assassin : Gladiator
    {
        private const float DodgingProbability = 50f;

        public Assassin()
        {
            Name = "Ассасин";
            Weapon = "Кинжал";
            WeaponInInstrumentalCase = "кинжалом";
            MaxHealth *= 0.8f;
            CurrentHealth = MaxHealth;
            ArmorInPercents *= 0.5f;
            Strength *= 0.9f;
            SpecialAbility = $"{DodgingProbability}% вероятность увернуться от удара.";
        }

        public override float TakeAHit(float damage)
        {
            if (Random.Next(0, MaxPercent) < DodgingProbability)
                return DodgeTheHit();
            else
                return base.TakeAHit(damage);
        }

        private float DodgeTheHit()
        {
            Logger.PrintMessage($"{Name} увернулся от удара.\n");
            return 0;
        }
    }
}
